#!/usr/bin/env python
# coding: utf-8

# # Исследование надёжности заёмщиков
# 
# Заказчик — кредитный отдел банка. Нужно разобраться, влияет ли семейное положение и количество детей клиента на факт погашения кредита в срок. Входные данные от банка — статистика о платёжеспособности клиентов.
# 
# Результаты исследования будут учтены при построении модели **кредитного скоринга** — специальной системы, которая оценивает способность потенциального заёмщика вернуть кредит банку.
# 
# **Цель исследования — проверьте четыре гипотезы:**
# 
# Есть зависимость между наличием детей и возвратом кредита в срок.
# 
# Есть зависимость между семейным положением и возвратом кредита в срок.
# 
# Есть зависимость между уровнем дохода и возвратом кредита в срок.
# 
# Разные цели кредита влияют на его возврат в срок.
# 

# ## Шаг 1. Откройте файл с данными и изучите общую информацию

# In[1]:


import pandas as pd
from pymystem3 import Mystem #сразу добавим Mystem
m = Mystem()
try: # открываем файл
    df = pd.read_csv('/datasets/data.csv') 
except: # альтернативный путь к файлу в случае ошибки
    df = pd.read_csv(r'C:\Users\vadim.pilipenko\Downloads\data.csv') 
df.info() 


# По выведенной информации о таблице видим, что имеется 12 колонок: 2 колонки с типом float64, 5 колонок с типом int64 и 5 колонок типа object. Количество значений в столбцах различается. Значит, в данных есть пропущенные значения. Выведем первые 15 строк данных:

# In[2]:


display(df.head(15))


# **Вывод**

# Согласно документации к данным:
# - children — количество детей в семье
# - days_employed — общий трудовой стаж в днях
# - dob_years — возраст клиента в годах
# - education — уровень образования клиента
# - education_id — идентификатор уровня образования
# - family_status — семейное положение
# - family_status_id — идентификатор семейного положения
# - gender — пол клиента
# - income_type — тип занятости
# - debt — имел ли задолженность по возврату кредитов
# - total_income — ежемесячный доход
# - purpose — цель получения кредита
# 
# По выведенным первым 15 строкам видна разный тип, регистр заполнения данных в ячейках колонок, требуется проверка на наличие пропусков, дубликатов и устранение ошибок в записи данных

# ## Шаг 2. Предобработка данных

# ### Обработка пропусков

# In[3]:


print('Рассмотрим распределение пропусков по столбцам:')
print(df.isna().sum()) #выведем количество явных пропусков по столбцам
print('')
print('Проверим распределение пропусков по типу занятости:')
print('')
income_type_list = df['income_type'].unique().tolist() # создадим список по типу занятости
for val in income_type_list: # обявление цикла по поиску пропусков по типу занятости
    output_info = df[df['income_type'] == val]['total_income'].isna().sum()
    print(f'пропуски значений по типузанятости {val}: {output_info}')


# Отсутствуют данные в колонках общий трудовой стаж в днях и ежемесячный доход и они совпадают
# Проверив распределение пропусков по типу занятости присвоим для провусков значения стажа и заработка по медиане групп, предварительно обработав ошибки.
# Выведем уникальные значения в столбцах:

# In[4]:



def unique_value_in_columns(data):
    value = data.columns.values.tolist()
    for val in value: #создаем цикл по просмотру уникальных значений по столбцам, ограничим вывод 15 строками
        print(f'уникальные значения в {val}: {data[val].unique()}')
        print('')
unique_value_in_columns(df)
        
    


# Оценив уникальные Значения в столбцах, видим ошибки в заполнении, приступаем к исправлению значений, например в значении количества детей из сета данных есть значение -1, а значение 20 детей стоит очень далеко от предпоследнего в 5 детй. в других столбцах так же есть подобные ошибки, усправим их.

# In[5]:


df['children'] = df['children'].abs().astype('int64') # через присвоение модуля значений убираем ошибочные отрицательные значения
children_median = df[df['children'] != 0]['children'].median()
df.loc[(df['children'] == 20), 'children'] = int(children_median) # меняем значение 20 детей на медианное количество детей семей с детьм

df.loc[(df['gender'] == 'XNA'), 'gender'] = 'F'

df['days_employed'] = df['days_employed'].abs() #через присвоение модуля значений убираем ошибочные отрицательные значения

dob_median = df[df['dob_years'] != 0]['dob_years'].median() #получаем медиану возраста из датасета 
df.loc[(df['dob_years'] == 0), 'dob_years'] = int(dob_median) #заменяем значение возраста 0 на медианное значение

df['education'] = df['education'].str.lower() #выравниваем строки с образованием на нижний регистр

df['total_income'] = df['total_income'].abs() #через присвоение модуля значений убираем ошибочные отрицательные значения


# Устранив ошибки ввода по категорийным данным и приведя данные по количественным данным к положительным значениям проверим количественные данные на ошибки по реальности цифр, разбив на группы по типу занятости.

# In[6]:


def min_mean_max_values_in_groupe(data, column_for_group, column_for_operations, val_correction=1, median=False):# создадим функцию по выводу данных по группам 
    try:
        values = data[column_for_group].unique().tolist()
        if median == False:
            for val in values:
                output_min = data[data[column_for_group] == val][column_for_operations].min()
                output_mean = data[data[column_for_group] == val][column_for_operations].mean()
                output_max = data[data[column_for_group] == val][column_for_operations].max()
                print(f'минимальное значение для {column_for_operations} по группе {val} равно: {output_min/val_correction}')
                print(f'среднее значение для {column_for_operations} по группе {val} равно: {output_mean/val_correction}')
                print(f'максимальное значение для {column_for_operations} по группе {val} равно: {output_max/val_correction}')
                print('')
        else:
            for val in values:
                output_min = data[data[column_for_group] == val][column_for_operations].min()
                output_median = data[data[column_for_group] == val][column_for_operations].median()
                output_max = data[data[column_for_group] == val][column_for_operations].max()
                print(f'минимальное значение для {column_for_operations} по группе {val} равно: {output_min/val_correction}')
                print(f'медианное значение для {column_for_operations} по группе {val} равно: {output_median/val_correction}')
                print(f'максимальное значение для {column_for_operations} по группе {val} равно: {output_max/val_correction}')
                print('')
        
    except:
        print('Произошла ошибка, проверьте введенные данные')
print('''посчитаем значения стажа по группам в годах
''')
min_mean_max_values_in_groupe(df,'income_type','days_employed',365)
        


# Видим очень странные цифры в группах пенсионер и безработный по годам стажа, предположим в этих колонках стаж указан не в дня а часах, проверим предположение, но стоит задать вопрос по данным сотрудникам заказчика исследования, предоставившим датасет

# In[7]:


days_mean_pension = df[df['income_type'] == 'пенсионер']['days_employed'].mean()  #вводим переменную для сохранения среднего значения
if (days_mean_pension) >= 365002: #пишем условие для исключения цикличной перезаписи значений
    df_pension_employed = df[df['income_type'] == 'пенсионер']['days_employed'] #вводим переменную для сохранения series 
    df_pension_employed /= 24
    df.loc[(df['income_type'] == 'пенсионер'),'days_employed'] = df_pension_employed #заменяем значения
days_mean_pension = df[df['income_type'] == 'пенсионер']['days_employed'].mean()
print(f'разделенные на 24 часа данные в значениях стажа по группе пенсионеры в среднем дают {days_mean_pension/365.25} года, что близко к реальности')

print(f'выясним количество записей и средний возраст безработного:')

count_unemployed = df[df['income_type'] == 'безработный']['dob_years'].count()
mean_unemployed_years = df[df['income_type'] == 'безработный']['dob_years'].mean()

print(f'количество записей в группе безработные: {count_unemployed}')
print(f'средний возраст в группе безработные: {mean_unemployed_years}')
print('''из полученных данных видим, что в данном случае правильно стаж по группе безработных присвоить
исходя из среднего стажа по возрасту в 38 лет''')

days_mean_38_years = df[df['dob_years'] == 38]['days_employed'].mean() #вводим переменную для сохранения среднего значения стажа в группе 38 лет
days_mean_unemployed = df[df['income_type'] == 'безработный']['days_employed'].mean()
if days_mean_unemployed >= 366413: #пишем условие для исключения цикличной перезаписи значений
    df.loc[(df['income_type'] == 'безработный'),'days_employed'] = days_mean_38_years #заменяем значения
days_mean_unemployed = df[df['income_type'] == 'безработный']['days_employed'].mean()


print(f'после замены на средний стаж по возрасту 38 лет стаж безработных получается: {days_mean_unemployed/365.25} года')
print('')
print('теперь заменим пропущенные значения по стажу средними значениями с разбивкой по группам занятости')
print('')

income_type_list = df['income_type'].unique().tolist()
try:
    for val in income_type_list:
        mean_val = df[df['income_type'] == val]['days_employed'].mean() #получаем среднее значение по типу занятости
        income_val = df[df['income_type'] == val]['days_employed'] # создаем series по типу занятости
        income_val = income_val.fillna(mean_val) # удаляем пропуски в series
        df.loc[(df['income_type'] == val),'days_employed'] = income_val # заменяем значения в фрейме
except:
    print('ошибка')
df.isna().sum()


# In[8]:


print('''посмотрим на данные по месячным заработкам по группам занятости:
''')

min_mean_max_values_in_groupe(df,'income_type','total_income',median=True)


print('''
Значения неоднозначные, например медианный заработок пенсионера всего на 15% ниже медианного заработка сотрудника,
что не похоже на показатели в России, но тут нужно обращаться к тем, кто предоставил датафрейм,
заменим пропуски используя медианные значения по типу занятости
''')

try:
    for val in income_type_list:
        median_val = df[df['income_type'] == val]['total_income'].median() #получаем среднее значение по типу занятости
        total_income_val = df[df['income_type'] == val]['total_income'] # создаем series по типу занятости
        total_income_val = total_income_val.fillna(median_val) # удаляем пропуски в series
        df.loc[(df['income_type'] == val),'total_income'] = total_income_val # заменяем значения в фрейме
except:
    print('ошибка')
    
df.isna().sum()


# **Вывод**

#    В данных есть пропуски в столбцах с количественными данными по стажу работников и месячному доходу, в связи с тем, что мы будем исследовать влияние уроввня дохода на возврат кредита, данные с пропусками были заменены с разбивкой по типу занятости на средние и медианные значения.
#    
#    Оценив уникальные значения в столбцах, исправлены ошибки в заполнении данных по разным столбцам, выравнены данные, заполненые разным  регистром.
#    
#    Возможная причина появления пропусков скорее всего ошибка записи данных, на это указывает то, что пропуски встречаются только в двух столбцах.
#    
#    Ошибки в записи данных распределены случайным образом по определенным столбцам, что возможно указывает на неполное или неточное заполнение данных клиентами.

# ### Замена типа данных

# В колличественных данных по дням занятости и по уровню месечного заработка данные воспринимать тяжело, заменим тип float64 на int64
# 

# In[9]:


df['days_employed'] = df['days_employed'].round(0).astype('int64') #округляем значения в столбце и меняем тип на int64
df['total_income'] = df['total_income'].round(0).astype('int64') #округляем значения в столбце и меняем тип на int64
df.info()
display(df.head(15))


# **Вывод**

# Для замены данных используем метод смены типа данных столбца "astype", предворительно округлив значения через "round"
# После замены типа значений данные стало читать и оценивать легче

# ### Обработка дубликатов

# In[10]:



print(f'Количество дубликатов строк в датасете: {df.duplicated().sum()}, удалим дублированные строки')
df = df.drop_duplicates().reset_index(drop=True)


# **Вывод**

# Дубликаты удалены методом "drop_duplicates" с перезаписью индекса строк, так как выше скрытые дубликаты в столбцах были
# устранены через приведение данных к общему виду записи.
# Возможные причины образования дубликатов - ошибка при записи данных при заполнении заявки, повторное заполнение формы клиентом.

# ### Лемматизация

# In[11]:


lemmas_list = []
df['purpose_lemmas'] = df.index #создадим столбец
df['purpose_lemmas'] = df['purpose_lemmas'].astype('object') #сменим тип данных на object в столбце
for i in range(len(df)): #создадим цикл, который пройдет по строкам и внесет леммы из столбца purpose в столбец purpose_lemmas
    df.at[i,'purpose_lemmas'] = m.lemmatize(df.loc[i,'purpose'])
    lemmas_list.extend(m.lemmatize(df.loc[i,'purpose'])) #создаем общий список лемм


    


# **Вывод**

# В таблицу добавлен столбец с леммами слов из столбца с целями кредита, для этого подключили Mystem из библиотеки pymystem

# <div style="border:solid grey 2px; padding: 20px"> 
#     
# *Ответ на комментарий ревьюера*
# 
# Комментарий понял, принял, нужно было вывести срез столбеца с выведенными леммами по таблице\
# и очистить от дублей леммы в общем списке лемм и оценить, какие будем использовать ввиде ключей для категоризации.
# </div>

# ### Категоризация данных

# In[12]:


def total_income_level(income): #разобъем на категории уровень дохода
    if income < 90000:
        return 'низкий'
    elif 90000 <= income < 160000:
        return 'средний'
    elif 160000 <= income < 280000:
        return 'выше среднего'
    else:
        return 'высокий'
df['total_income_level'] = df['total_income'].apply(total_income_level)


clear_lemmas_list = [] # очистим общий список лемм от дубликатов и оценим основные леммы для категоризации целей кредитов
for val in lemmas_list:
    if val not in clear_lemmas_list:
        clear_lemmas_list.append(val)
print(f'Рассмотрим список лемм для выбора ключевых лемм для категоризации целей: {clear_lemmas_list}\n \n')

def purpose_categories(lemmas): #категоризируем цели кредита
    try:
        if lemmas.count('автомобиль') > 0:
            return 'автомобиль'
        elif lemmas.count('образование') > 0:
            return 'образование'
        elif lemmas.count('свадьба') > 0:
            return 'свадьба'
#        elif lemmas.count('жилье') > 0 or lemmas.count('недвижимость') > 0 and lemmas.count('ремонт') > 0:
#            return 'ремонт жилья'
#        elif lemmas.count('жилье') > 0 or lemmas.count('недвижимость') > 0 and lemmas.count('строительство') > 0:
#            return 'строительство жилья'
#        elif lemmas.count('операция') > 0 or lemmas.count('коммерческий') > 0 and lemmas.count('недвижимость') > 0:
#            return 'коммерческая недвижимость'
#        elif lemmas.count('жилье') > 0 or lemmas.count('недвижимость') > 0 and lemmas.count('покупка') > 0 or lemmas.count('приобретение') > 0  :
#            return 'приобретение недвижимости'
        elif lemmas.count('жилье') > 0 or lemmas.count('недвижимость') > 0 :
            return 'недвижимость'
        else:
            return 'другое'
    except:
        print('здесь ошибка')
df['purpose_categories'] = df['purpose_lemmas'].apply(purpose_categories)


def children_categories(children): #категоризируем количество детей
    try:
        if children == 0:
            return 'нет детей'
        elif children == 1:
            return 'один ребенок'
        elif children == 2:
            return 'двое детей'
        else:
            return 'многодетные'
    except:
        print('здесь ошибка')
df['children_categories'] = df['children'].apply(children_categories)


def years_categories(years): #категоризирум возраст
    try:
        if years < 35:
            return 'молодой возраст'
        elif 35 <= years < 55:
            return 'средний возраст'
        else:
            return 'пожилой возраст'
    except:
        print('здесь ошибка')
df['dob_years_categories'] = df['dob_years'].apply(years_categories)


def employed_categories(employed): #категоризирум стаж
    try:
        if employed < 365:
            return 'меньше года'
        elif 365 <= employed < 1826:
            return 'до пяти лет'
        elif 1826 <= employed < 3652:
            return 'до десяти лет'
        else:
            return 'свыше десяти лет'
    except:
        print('здесь ошибка')

df['years_employed_categories'] = df['days_employed'].apply(employed_categories)


df_educ = df.groupby('education')['debt'].count()
df_family = df.groupby('family_status')['debt'].count()

print(f'Оценим количество по группам по образованию:\n{df_educ}\n \n и по семейному статусу: \n{df_family}\n\n')
print(f'В группах по образованию начальное и среднее можно объединить в среднее, группы неоконченное высшее и ученая степень объединим с группой высшее')
print(f'В группах по семейному статусу группы вдовец/вдова и в разводе можно объединить в одну группу')

df.loc[df['education'] == 'начальное', 'education'] = 'среднее'
df.loc[df['education'] == 'неоконченное высшее', 'education'] = 'высшее'
df.loc[df['education'] == 'ученая степень', 'education'] = 'высшее'

df.loc[df['family_status'] == 'в разводе', 'family_status'] = 'в разводе / вдовец / вдова'
df.loc[df['family_status'] == 'вдовец / вдова', 'family_status'] = 'в разводе / вдовец / вдова'


# **Вывод**

# Для исследования категоризированны данные по уровню дохода, целям кредита, наличию детей, возрасту заемщика, стажу. 

# ## Шаг 3. Ответьте на вопросы

# - Есть ли зависимость между наличием детей и возвратом кредита в срок?

# In[28]:


def ratio_in_procent(x): #объявим переменную для вывода разницы в процентах для подстановки в aggfunc
    ratio = round(x.sum()/x.shape[0]*100,2)
    return ratio

df_pivot_children = df.pivot_table(index='children_categories', values='debt',aggfunc=['sum','count', ratio_in_procent]) #объявим переменную c сводной таблицей по категории детей 

df_debt_all = df['debt'].sum() / df['debt'].count()
display(df_pivot_children, 'Невозврат кредита по всей выборке: {:.2%}'.format(df_debt_all))

df_pivot_children_2 = df.pivot_table(index='children_categories', columns='family_status',values='debt', aggfunc=ratio_in_procent)#объявим переменную c сводной таблицей по категории детей с группировкой по ктегориям семейного статуса

display(df_pivot_children_2)


# **Вывод**

# - При сравнении показателей по сводным таблицам, видно, что при отсутствии детей процент невозврата кредита ниже среднего по всем данным сета, при наличие детей выше среднего, при разбивке на 1, 2 и 3+ детей в семье, при наличие 1 или 2 детей процент невыплаты выше среднего, для семей с 3+ деней выборка недостаточно, сложно оценить,
# - При рассмотрении влияния наличия детей с разбивкой на семейный статус видно значительное взаимное влияние факторов по количеству детей и семейному статусу.
# 
# Есть зависимость между наличием детей и возвратом кредита в срок. Заемщики без детей надежнее чем с детьми, но наличие одного ребенка для групп заемщиков в браке или бывших в браке не выше среднего риска, наибольший процент невозврата кредита в срок приходится на заемщика с детьми не в браке или в гражданском браке.

# - Есть ли зависимость между семейным положением и возвратом кредита в срок?

# In[26]:


df_pivot_family_s = df.pivot_table(index='family_status', values='debt', aggfunc=['sum','count',ratio_in_procent]) #объявим переменную c сводной таблицей по категории семейного статуса 

display(df_pivot_family_s,'Невозврат кредита по всей выборке: {:.2%}'.format(df_debt_all))
df_pivot_family_s_2 = df.pivot_table(index='family_status', columns='years_employed_categories',                      values='debt', aggfunc=ratio_in_procent) #объявим переменную c сводной таблицей по категории семейного статуса с группировкой по стажу
display(df_pivot_family_s_2)


# **Вывод**

# - При сравнении показателей по сводным таблицам, видно, что семейный статус влияет на возврат кредита в срок. В статусах в женат/замужем и в разводе/вдовец/вдова доля невозврата кредита в срок ниже чем у групп не женатых и состоящих в гражданском браке.
# - При рассмотрении влияния наличия статуса с разбивкой на стаж видно понижение процента невозврата кредита в срок с ростом стажа практически во всех группах.
# 
# Есть зависимость между семейным положением и возвратом кредита в срок. Кредитовать людей состоящих или состоявших в браке надежнее.

# - Есть ли зависимость между уровнем дохода и возвратом кредита в срок?

# In[26]:


df_pivot_income = df.pivot_table(index='total_income_level', values='debt', aggfunc=['sum','count',ratio_in_procent]) #объявим переменную c сводной таблицей по категории уровня дохода 
display(df_pivot_income,f'Невозврат кредита по всей выборке: {df_debt_all} %')
df_pivot_income_2 = df.pivot_table(index='total_income_level', columns='education',                    values='debt', aggfunc=ratio_in_procent) #объявим переменную c сводной таблицей по категории уровня дохода с группировкой по образования
display(df_pivot_income_2)


# **Вывод**

# - При сравнении показателей по сводным таблицам, видно, что уровень дохода влияет на возврат кредита в срок незначительно. В группе с высокими доходами процент невозврата ниже, в остальных группах близок к среднему по сету данных.
# - При рассмотрении влияния уровня дохода с разбивкой на образование видно, что в группе с высшим образованием примерно соблюдается последовательность: чем выше доход тем ниже процент невозврата в срок. В группе с средним образованием такой последовательности по уровню дохода не прослеживается.
# 
# Зависимость невозврата кредита в срок от уровня дохода есть в группе с вышим образованием, в общем по группе четкой зависимости нет. Стоит обращать внимание на уровень дохода заемщиков с высшим образованием.

# - Как разные цели кредита влияют на его возврат в срок?

# In[27]:


df_pivot_purpose = df.pivot_table(index='purpose_categories', values='debt', aggfunc=['sum','count', ratio_in_procent]) #объявим переменную c сводной таблицей по категории цели кредита 
display(df_pivot_purpose,'Невозврат кредита по всей выборке: {:.2%}'.format(df_debt_all)) 

df_pivot_purpose_2 = df.pivot_table(index='purpose_categories', columns='dob_years_categories',                     values='debt', aggfunc=[ratio_in_procent]) #объявим переменную c сводной таблицей по категории цели кредита с группировкой по возрасту заемщика
display(df_pivot_purpose_2)


# **Вывод**

# - При сравнении показателей по сводным таблицам, видно, что цель кридита влияет на возврат кредита в срок. Для целей кредита на недвижимость процент невозврата в срок ниже других групп и ниже среднего процента по сету. Для цели свадьба процент невозврата вовремя примерно равен среднему проценту по сету. Для целей на автомобиль и на образование процент невозврата вовремя выше целей на недвижимость и не свадьбу и выше среднего по сету.
# - При рассмотрении влияния целей кредита по группам возраста зависимость сохраняется одинаковой для всех групп возраста.
# 
# Зависимость невозврата кредита в срок от цели кредита есть. Кредитовать недвижимость предпочтительнее, чем кредитовать на автомобиль или образование.

# ## Шаг 4. Общий вывод

# Зависимость между наличием детей и невозвратом кредита в срок, семейным положением и невозвратом кредита в срок, целью кредита и невозвратом кредита в срок есть, между уровнем дохода и возвратом кредита в срок не очевидна, но оптимально рассматривать влияние разных факторов вместе при достаточно большом количестве данных.

# ## Чек-лист готовности проекта
# 
# Поставьте 'x' в выполненных пунктах. Далее нажмите Shift+Enter.

# - [x]  открыт файл;
# - [x]  файл изучен;
# - [x]  определены пропущенные значения;
# - [x]  заполнены пропущенные значения;
# - [x]  есть пояснение, какие пропущенные значения обнаружены;
# - [x]  описаны возможные причины появления пропусков в данных;
# - [x]  объяснено, по какому принципу заполнены пропуски;
# - [x]  заменен вещественный тип данных на целочисленный;
# - [x]  есть пояснение, какой метод используется для изменения типа данных и почему;
# - [x]  удалены дубликаты;
# - [x]  есть пояснение, какой метод используется для поиска и удаления дубликатов;
# - [x]  описаны возможные причины появления дубликатов в данных;
# - [x]  выделены леммы в значениях столбца с целями получения кредита;
# - [x]  описан процесс лемматизации;
# - [x]  данные категоризированы;
# - [x]  есть объяснение принципа категоризации данных;
# - [x]  есть ответ на вопрос: "Есть ли зависимость между наличием детей и возвратом кредита в срок?";
# - [x]  есть ответ на вопрос: "Есть ли зависимость между семейным положением и возвратом кредита в срок?";
# - [x]  есть ответ на вопрос: "Есть ли зависимость между уровнем дохода и возвратом кредита в срок?";
# - [x]  есть ответ на вопрос: "Как разные цели кредита влияют на его возврат в срок?";
# - [x]  в каждом этапе есть выводы;
# - [x]  есть общий вывод.

# In[ ]:




